# 第26章

## 第1题

根据题目，先看这段汇编语言（loop.s）

~~~x86asm
.main
.top
sub  $1,%dx
test $0,%dx
jgte .top
halt
~~~

这段代码的流程是:

1. `dx`寄存器的值减1
2. 判断`dx`寄存器的值是非负数就跳转到`.top`处
3. 如果不满足跳转条件就结束

就是循环对`dx`寄存器减1, 直到`dx`是`-1`.

查看要运行的指令:

![1.1.png](pic/1.1.png)

首先要知道这个dx寄存器的初始值是多少。查看README没看到，那么直接查看python代码，发现了初始化默认为0。代码如下，在第99行处。

![python_init](pic/1.1python.png)

所以根据初始值（`dx = 0`）带入到上述流程中，得到：

| `dx` | 操作 |
| :--: | :--: |
| 0 | init |
| -1 | dx - 1 |
| -1 | dx < 0 |
| -1 | 不跳转 |
| -1 | halt, 停机 |

查看答案

![answer](pic/1.1answer.png)

基本一致，推论正确

## 第2题

使用指令：`./x86.py -p loop.s -t 2 -i 100 -a dx=3,dx=3 -R dx`

先分析指令：

1. 还是使用上一个问题代码`loop.s`
2. 有两个线程，dx寄存器初始化为3.
3. 线程切换是在每个线程执行了100条指令之后（远远大于每个线程每次循环执行指令数）

查看指令输出结果：

![Question](2.2q.png)

按照流程，以第一个线程为例分析（第二个线程完全一致）：

| `dx` | 操作 |
| :--: | :--: |
| 3 | init |
| 2 | dx -1 |
| 2 | dx >= 0 |
| 2 | 继续循环 |
| 1 | dx -1 |
| 1 | dx >= 0 |
| 1 | 继续循环 |
| 0 | dx -1 |
| 0 | dx >= 0 |
| 0 | 继续循环 |
| -1 | dx - 1 |
| -1 | dx < 0 |
| -1 | 不跳转 |
| -1 | halt, 停机 |

两个线程完全一致是因为两次的`dx`寄存器都经历了初始化为3的操作。而且使用的是相同的代码，更重要的是：**在这段代码python仿真的x86的pc寄存器中，看到了每个线程执行的指令数目远远小于100。所以在执行完一个线程之前，并不会发生线程切换。所以根本不存在数据的覆盖和进程的冲突**

查看答案：

![answer](2.2a.png)

完全一致，说明推论正确，同时再次验证了第一问的推论是有普适性的。

## 第3题

这道题承接上一个问，只不过上一个问中没有线程来回切换，但是这个问中两个线程高频来回切换。要去考量这种高频率的切换会不会带来问题。

其实这个题目问的就是当出现了线程切换的时候是不是又上下文（contest）的保护机制，这个问题需要查看README或者python文件，看这个仿真程序是不是有这种机制。

在README中没有找到相关描述，但是在python中找到了。代码如下图，先看上面三个是相应的函数定义，下面虚线之下是主函数中调用的部分。

![python](2.3py.png)

可以看到这段代码中体现了在中断（interrupt）的时候会执行三个函数，分别是：

|函数名|作用|
|--|--|
|`save`|当前线程使用寄存器的保存|
|`restore`|要切换的线程使用数据的加载|
|`next`|上下文切换（contest switch）|

这就说明不论是怎样切换线程，都有数据的保护机制，保证线程之间的数据不会互相干扰。

这道题要求用多个随机种子，为了方便，我写了一个脚本：

![shell](2.3sh.png)

这段脚本按顺序生成随机种子0~9，并输出结果：

![answer](2.3a.png)

查看了所有的随机种子，并没有发现数据出错，说明这个x86的仿真程序没有问题。

## 第4题

先研究一下给出的程序：

![code](2.4s.png)

这段程序在README中有描述：

> The code has a critical section which loads the value of a variable (at address 2000), then adds 1 to the value, then stores it back. \
> The code after just decrements a loop counter (in %bx), tests if it is greater than or equal to zero, and if so, jumps back to the top to the critical section again.

就是说：

> 代码有一个关键部分，该节加载变量的值（在地址 2000 处），然后将 1 添加到该值，然后将其存储回。\
>代码在刚刚递减循环计数器（在 bx 中）后，测试其是否大于或等于零，如果是，则再次跳回顶部到关键部分。

这里命令`./x86.py -p looping-race-nolock.s -t 1 -M 2000`没有给出`bx`寄存器的值，按照第一个问的分析可知：默认为0.那么整个程序的流程：

|寄存器`ax`|寄存器`bx`|地址2000的值|操作|
|--|--|--|--|
|0|0|0| init|
|0|0|0|把内存2000的值加载到寄存器`ax`上|
|1|0|0|`%ax` += 1|
|1|0|1|把寄存器`ax`上加载到内存2000的值|
|1|-1|1|`%bx` -= 1|
|1|-1|1|`%bx` < 0|
|1|-1|1|不跳转|
|1|-1|1|结束线程|

这个单线程的程序,最后得到的内存两千的值为1

观察答案，完全一致，说明正确。

![answer](2.4a.png)

为了证明推理过程,查看ax和bx寄存器,观察是否符合推理过程,使用指令`python2 ./x86.py -p looping-race-nolock.s -t 1 -M 2000 -R ax,bx -c`

![answer_check_2](2.4aexp.png)

还是完全一致,说明结果正确.
